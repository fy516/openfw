/**
 * @brief Service Base Interface
 *
 * @author WindEagle <fy516a@gmail.com>
 * @version 1.0.0
 * @date 2020-01-01 00:00
 * @copyright Copyright (c) 2020-2023 ZyTech Team
 * @par Changelog:
 * Date                 Version     Author          Description
 */
//################################################################################
// Include header file
//################################################################################
#include "IServiceBase.h"
#include "../common/enchelper.h"
#include "../common/filehelper.h"
#include "../common/loghelper.h"
#include "../common/syshelper.h"
#ifdef _LINUX
    #include <sys/file.h>
    #include <sys/wait.h>
#endif

//################################################################################
// Define inside macro
//################################################################################
#ifdef _WINDOWS
    // The accepted commands of the service.
    #define SERVICE_CONTROLS_ACCEPTED (SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PRESHUTDOWN)

    // Pass the child process index (Main process to child process)
    #define WM_CHILD_PROC_CUR_IDX WM_USER + 0x0001

    // Pass the message thread ID of the child process (Child process to main process)
    #define WM_CHILD_PROC_MSG_TID WM_USER + 0x0002

    // Control the child process termination (Main process to child process)
    #define WM_CTRL_CHILD_PROC_STOP WM_USER + 0x0003
#endif
#ifdef _LINUX
    // The listen signals of the service.
    #define SERVICE_LISTEN_SIGNALS                                                                                                                                                       \
        {                                                                                                                                                                                \
            {SIGHUP,  false}, /* [IGNORE] The user terminal ends the signal */                                                                                                           \
            {SIGINT,  false}, /* [IGNORE] Interrupt signal (enter CTRL+C in the terminal to interrupt the foreground process) */                                                         \
            {SIGQUIT, false}, /* [IGNORE] Exit signal (enter CTRL+\ in the terminal to exit the foreground process and generate a CORE file at the same time) */                         \
            {SIGALRM, false}, /* [IGNORE] The timer timed out */                                                                                                                         \
            {SIGTERM, true},  /* [LISTEN] Process termination signal */                                                                                                                  \
            {SIGCHLD, true},  /* [LISTEN] Signal to control child process termination */                                                                                                 \
            {SIGTSTP, false}, /* [IGNORE] Pause signal (generated by CTRL+Z, which causes the foreground process to hang) */                                                             \
            {SIGIO,   false}, /* [IGNORE] Asynchronous I/O */                                                                                                                            \
            {SIGSYS,  false}, /* [IGNORE] Invalid system call */                                                                                                                         \
            {SIGPIPE, false}, /* [IGNORE] Write to a pipe with no read process (when the pipe read end is closed, continue to write to the pipe, generating this signal) */              \
            {SIGUSR1, false}  /* [IGNORE] Synchronous child process list signal (generated when the child process terminates abnormally and the parent process creates a new process) */ \
        }
#endif

//################################################################################
// Define inside class
//################################################################################
namespace ofw
{
#ifdef _WINDOWS
    /**
     * @brief Service daemon
     */
    class IServiceDaemon
    {
    public:
        /**
         * @brief Child process information
         */
        struct TChildProcess
        {
            HANDLE    procHandle = nullptr; // Process pid
            pthread_t procMsgTid = 0;       // Message thread id
        };

    public:
        static IServiceDaemon * This;            // A static instance of itself
        IServiceBase *          svcInstance;     // IServiceBase instance
        char *                  svcName;         // Service name
        std::unique_ptr<char[]> svcAppPath;      // Service application path
        bool                    svcStopping;     // Whether the service is terminating
        uint                    childTotal;      // The child processes total
        TChildProcess *         childList;       // The child processes list
        SERVICE_STATUS          svcStatus;       // Service status
        SERVICE_STATUS_HANDLE   svcStatusHandle; // Service status handle
        DWORD                   svcCheckPoint;   // Service check point

    public:
        /**
         * @brief [STATIC] Service control handler (Called whenever service control manager updates service status)
         *
         * @param ctrlCode Control code (Example: SERVICE_CONTROL_STOP)
         * @param evtType  Event type (The type of event that has occurred; Example: DBT_DEVICEARRIVAL)
         * @param evtData  Event data (Additional device information, if required)
         * @param context  User-defined data passed from RegisterServiceCtrlHandlerEx
         * @return Exit code (EXIT_SUCCESS: successed; Other: failed)
         */
        static DWORD WINAPI ServiceCtrlHandler(DWORD ctrlCode, DWORD evtType, void * evtData, void * context);

        /**
         * @brief [STATIC] Service main function (Registers handle and starts the service)
         *
         * @param argCount  Arguments count
         * @param argValues Arguments value
         */
        static VOID WINAPI ServiceMain(DWORD argCount, LPSTR argValues[]);

    public:
        /**
         * @brief Write to the windows sytem event log
         *
         * @param logMessage Event log message
         * @param logType    Event log type (Example: EVENTLOG_ERROR_TYPE)
         */
        void writeSystemEventLog(const char * logMessage, WORD logType);

        /**
         * @brief Sets the current service status and reports it to the SCM.
         *
         * @param curStatus The current state (Example: SERVICE_START_PENDING)
         * @param errCode   The system error code (Default: NO_ERROR)
         * @param waitHint  Estimated time for pending operation (Unit: milliseconds; Default: 0)
         */
        void reportServiceStatus(DWORD curStatus, DWORD errCode = NO_ERROR, DWORD waitHint = 0);

        /**
         * @brief Create a child process
         *
         * @param procIndex Child process index (Start with: 0)
         * @return Whether the create is successful
         */
        bool createChildProcess(uint procIndex);

        /**
         * @brief Release a child process
         * 
         * @param procIndex Child process index (Start with: 0)
         */
        void releaseChildProcess(uint procIndex);

        /**
         * @brief Create and daemonize child processes
         *
         * @return Whether the execute is successful
         */
        bool daemonChildProcesses();

    public:
        /**
         * @brief Construct function
         *
         * @param svcInstance IServiceBase instance
         * @param svcName     Service name
         * @param childTotal  The child processes total
         */
        IServiceDaemon(IServiceBase * svcInstance, const char * svcName, uint childTotal);

        /**
         * @brief Destruct function
         */
        ~IServiceDaemon();
    };
#endif
#ifdef _LINUX
    /**
     * @brief Service daemon (Used only for the main process)
     */
    class IServiceDaemon
    {
    public:
        static IServiceDaemon * This;        // A static instance of itself
        IServiceBase *          svcInstance; // IServiceBase instance
        char *                  svcName;     // Service name
        bool                    svcStopping;  // Whether the service is terminating
        uint                    childTotal;  // The child processes total
        pid_t *                 childList;   // The child processes pid list

    public:
        /**
         * @brief [STATIC] Signal handler
         *
         * @param sigNum     Trigger signal
         * @param sigInfo    Signal information
         * @param sigContext Signal context
         */
        static void SignalHandler(int sigNum, siginfo_t * sigInfo, void * sigContext);

    public:
        /**
         * @brief Create a PID file of the daemon service
         *
         * @return Whether the create was successful
         */
        bool createPidFile();

        /**
         * @brief Remove a PID file of the daemon service
         *
         * @return Whether the remove was successful
         */
        bool removePidFile();

        /**
         * @brief Convert the current process to a daemon
         *
         * @param isChdir Whether to change the working directory (Change to "/")
         * @param noPrint Whether to disable print (Disable console output)
         * @return Whether the conversion was successful
         */
        bool initDaemonProcess(bool isChdir, bool noPrint);

        /**
         * @brief Initialize the listening signal of the current process
         *
         * @return Whether the initialize is successful
         */
        bool initListenSignals();

        /**
         * @brief Create and daemonize child processes
         *
         * @return Whether the execute is successful
         */
        bool daemonChildProcesses();

        /**
         * @brief Handle child process termination event
         *
         * @param childPid PID of the child process
         */
        void onChildTerminate(pid_t childPid);

    public:
        /**
         * @brief Construct function
         *
         * @param svcInstance IServiceBase instance
         * @param svcName     Service name
         * @param childTotal  The child processes total
         */
        IServiceDaemon(IServiceBase * svcInstance, const char * svcName, uint childTotal);

        /**
         * @brief Destruct function
         */
        ~IServiceDaemon();
    };
#endif

    /**
     * @brief Service private (Used only for the child process)
     */
    class IServicePrivate
    {
    public:
        static IServicePrivate * This;        // A static instance of itself
        IServiceBase *           svcInstance; // IServiceBase instance
        uint                     procIndex;   // Child process index
        bool                     svcStopping; // Whether the service is terminating
#ifdef _WINDOWS
        HANDLE                   msgThread;   // Message receiving thread handle
#endif

#ifdef _WINDOWS
    public:
        /**
         * @brief Message receiving thread (Used to receive process stop message sent by the parent process)
         *
         * @param lpParam Thread parameter
         * @return Exit code (EXIT_SUCCESS: successed; Other: failed)
         */
        static DWORD WINAPI MessageThread(LPVOID lpParam)
        {
            WPARAM parent_tid = reinterpret_cast<WPARAM>(static_cast<WPARAM *>(lpParam));
            MSG    proc_msg   = {0};
            while (!This->svcStopping)
            {
                if (::GetMessageA(&proc_msg, NULL, 0, 0) && proc_msg.message == WM_CTRL_CHILD_PROC_STOP && proc_msg.lParam == This->procIndex)
                {
                    This->svcStopping = true;
                }
            }
            return EXIT_SUCCESS;
        }
#endif

    public:
        /**
         * @brief Construct function
         *
         * @param svcInstance IServiceBase instance
         * @param svcName     Service name
         * @param procIndex   Child process index (Start with: 1)
         */
        IServicePrivate(IServiceBase * svcInstance, uint procIndex) : svcInstance(svcInstance), procIndex(procIndex), svcStopping(false)
        {
            this->This = this;
#ifdef _WINDOWS
            this->msgThread = nullptr;
#endif
        }

        /**
         * @brief Destruct function
         */
        ~IServicePrivate()
        {
#ifdef _WINDOWS
            DWORD exit_code;
            if (::GetExitCodeThread(this->msgThread, &exit_code) && exit_code == STILL_ACTIVE) ::TerminateThread(this->msgThread, EXIT_SUCCESS);
            ::CloseHandle(this->msgThread);
#endif
            this->This = nullptr;
        }
    };
}

//################################################################################
// Implementation inside class
//################################################################################
//============================================================
// Service daemon
//============================================================
#ifdef _WINDOWS
/**
 * @brief [STATIC] Service control handler (Called whenever service control manager updates service status)
 *
 * @param ctrlCode Control code (Example: SERVICE_CONTROL_STOP)
 * @param evtType  Event type (The type of event that has occurred; Example: DBT_DEVICEARRIVAL)
 * @param evtData  Event data (Additional device information, if required)
 * @param context  User-defined data passed from RegisterServiceCtrlHandlerEx
 * @return Exit code (EXIT_SUCCESS: successed; Other: failed)
 */
DWORD WINAPI ofw::IServiceDaemon::ServiceCtrlHandler(DWORD ctrlCode, DWORD evtType, void * evtData, void * context)
{
    // Define inside variable
    DWORD ret_code = EXIT_SUCCESS; // The code value used to return

    // The processing that the service stops (Check whether receive a valid end-of-service control code)
    if (This->svcStatus.dwCurrentState == SERVICE_RUNNING && (ctrlCode == SERVICE_CONTROL_STOP || ctrlCode == SERVICE_CONTROL_PRESHUTDOWN))
    {
        // Change the service status to Stopping
        This->reportServiceStatus(SERVICE_STOP_PENDING);

        // Change service status to stopping
        This->svcStopping = true;

        // Wait for all child processes to terminate
        for (uint child_idx = 0; child_idx < This->childTotal; child_idx++) This->releaseChildProcess(child_idx);

        // Change the service status to Stopped
        This->reportServiceStatus(SERVICE_STOPPED);
    }

    // Return execute result
    return ret_code;
}

/**
 * @brief [STATIC] Service main function (Registers handle and starts the service)
 *
 * @param argCount  Arguments count
 * @param argValues Arguments value
 */
VOID WINAPI ofw::IServiceDaemon::ServiceMain(DWORD argCount, LPSTR argValues[])
{
    // Define inside variable
    std::unique_ptr<char[]> svc_name = ofw::utf8_to_ansi(This->svcName); // The service name of the ANSI encoding

    // Register a function that handles extended service control requests
    if (!(This->svcStatusHandle = ::RegisterServiceCtrlHandlerExA(svc_name.get(), ServiceCtrlHandler, NULL)))
    {
        This->writeSystemEventLog("Can't set service control handler.", EVENTLOG_ERROR_TYPE);
        return;
    }

    // The processing that the service start
    {
        // Define temporary variables
        bool start_status = true; // Service start stauts

        // Change the service status to starting
        This->reportServiceStatus(SERVICE_START_PENDING);

        // Create all child processes
        for (uint child_idx = 0; child_idx < This->childTotal; child_idx++)
        {
            // Create a child process
            if (!(start_status = This->createChildProcess(child_idx)))
            {
                This->writeSystemEventLog("An exception occurred while the service starting.", EVENTLOG_ERROR_TYPE);
                break;
            }
        }

        // The all child processes started successfully
        if (start_status)
        {
            // Change the service status to running
            This->reportServiceStatus(SERVICE_RUNNING);
        }
        // There are child processes that failed to start
        else
        {
            // Change the service status to Stopping
            This->reportServiceStatus(SERVICE_STOP_PENDING);

            // Terminate started child processes
            for (uint child_idx = 0; child_idx < This->childTotal; child_idx++) This->releaseChildProcess(child_idx);

            // Change the service status to Stopped
            This->reportServiceStatus(SERVICE_STOPPED);

            // Return
            return;
        }
    }

    // Daemon child processes
    {
        // Define temporary variables
        std::unique_ptr<HANDLE[]> all_childs(new HANDLE[This->childTotal]); // Handles to all child processes
        bool                      create_status = false;                    // The success status of the child process created
        DWORD                     exit_code     = 0;                        // Child process exit code

        // Wait service stopping
        while (!This->svcStopping)
        {
            // Initializes the creation status of the child process
            create_status = true;

            // Check the status of all child processes
            for (uint proc_idx = 0; proc_idx < This->childTotal; proc_idx++)
            {
                // The child process was terminated
                if (!(::GetExitCodeProcess(This->childList[proc_idx].procHandle, &exit_code) && exit_code == STILL_ACTIVE))
                {
                    // Resurrect child process
                    if (!This->createChildProcess(proc_idx))
                    {
                        This->writeSystemEventLog("Failed to create child process, will automatically retry later.", EVENTLOG_WARNING_TYPE);
                        create_status = false;
                        break;
                    }
                }

                // Record the process handle to be daemonized
                all_childs[proc_idx] = This->childList[proc_idx].procHandle;
            }

            // The child process status is normal
            if (create_status)
                ::WaitForMultipleObjects(This->childTotal, all_childs.get(), FALSE, INFINITE);
            // Failed to resume child process
            else
                ofw::sleep_milliseconds(100);
        }
    }
}

/**
 * @brief Write to the windows sytem event log
 *
 * @param logMessage Event log message
 * @param logType    Event log type (Example: EVENTLOG_ERROR_TYPE)
 */
void ofw::IServiceDaemon::writeSystemEventLog(const char * logMessage, WORD logType)
{
    // Define inside variable
    std::unique_ptr<char[]> svc_name     = ofw::utf8_to_ansi(this->svcName);             // The service name of the ANSI encoding
    std::unique_ptr<char[]> log_message  = ofw::utf8_to_ansi(logMessage);                // The log message of the ANSI encoding
    HANDLE                  event_handle = ::RegisterEventSourceA(NULL, svc_name.get()); // The event handle represented by the source name

    // Check the event handle
    if (event_handle)
    {
        // Define temporary variables
        const char * event_datas[2] = {svc_name.get(), log_message.get()}; // Event datas

        // Write event log
        ::ReportEventA(event_handle, logType, 0, 0, NULL, 2, 0, event_datas, NULL);

        // Release the event handle
        ::DeregisterEventSource(event_handle);
    }
}

/**
 * @brief Sets the current service status and reports it to the SCM.
 *
 * @param curStatus The current state (Example: SERVICE_START_PENDING)
 * @param errCode   The system error code (Default: NO_ERROR)
 * @param waitHint  Estimated time for pending operation (Unit: milliseconds; Default: 0)
 */
void ofw::IServiceDaemon::reportServiceStatus(DWORD curStatus, DWORD errCode, DWORD waitHint)
{
    // Update the service status value
    this->svcStatus.dwCurrentState  = curStatus;
    this->svcStatus.dwWin32ExitCode = errCode;
    this->svcStatus.dwWaitHint      = waitHint;

    // During service startup, any control operations are prohibited
    this->svcStatus.dwControlsAccepted = (curStatus == SERVICE_START_PENDING ? 0 : SERVICE_CONTROLS_ACCEPTED);

    // Update check point
    // The check-point value the service increments periodically to report its progress during a lengthy start, stop, pause, or continue operation.
    this->svcStatus.dwCheckPoint = (curStatus == SERVICE_RUNNING || curStatus == SERVICE_STOPPED ? 0 : this->svcCheckPoint++);

    // Set the service status
    ::SetServiceStatus(this->svcStatusHandle, &this->svcStatus);
}

/**
 * @brief Create a child process
 *
 * @param procIndex Child process index (Start with: 0)
 * @return Whether the create is successful
 */
bool ofw::IServiceDaemon::createChildProcess(uint procIndex)
{
    // Initialize the child process list
    if (!this->childList)
    {
        this->childList = new TChildProcess[this->childTotal];
        ::memset(this->childList, 0, this->childTotal * sizeof(TChildProcess));
    }

    // Release the child process that has been created
    if (this->childList[procIndex].procHandle) this->releaseChildProcess(procIndex);

    // Initialize the child daemon threads
    {
        // Define temporary variables
        PROCESS_INFORMATION proc_info;  // Child process information
        STARTUPINFO         start_info; // Child process start information
        MSG                 proc_msg;   // Child process message
        DWORD               exit_code;  // Child process exit code

        // Initialize variables
        ::memset(&proc_info,  0, sizeof(proc_info));
        ::memset(&start_info, 0, sizeof(start_info));
        ::memset(&proc_msg,   0, sizeof(proc_msg));

        // Create child process (If it fails, terminate the creation of the child process)
        if (!::CreateProcessA(NULL, ::GetCommandLineA(), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &start_info, &proc_info)) return false;
        This->childList[procIndex].procHandle = proc_info.hProcess;

        // Close the thread handle of the child process
        if (proc_info.hProcess != proc_info.hProcess) ::CloseHandle(proc_info.hThread);

        // Send process index to child process
        while (!::PostThreadMessageA(proc_info.dwThreadId, WM_CHILD_PROC_CUR_IDX, OFW_CUR_THREAD_ID, procIndex + 1))
        {
            if (::GetExitCodeProcess(proc_info.hProcess, &exit_code) && exit_code == STILL_ACTIVE)
            {
                ofw::sleep_milliseconds(50);
            }
            else
            {
                this->releaseChildProcess(procIndex);
                return false;
            }
        }

        // Wait for the child process to return the message thread id
        while (!::PeekMessageA(&proc_msg, NULL, 0, 0, PM_REMOVE) || proc_msg.message != WM_CHILD_PROC_MSG_TID || proc_msg.wParam != proc_info.dwThreadId)
        {
            if (::GetExitCodeProcess(proc_info.hProcess, &exit_code) && exit_code == STILL_ACTIVE)
            {
                ofw::sleep_milliseconds(50);
            }
            else
            {
                this->releaseChildProcess(procIndex);
                return false;
            }
        }

        // Update the message thread ID of the child process
        This->childList[procIndex].procMsgTid = static_cast<pthread_t>(proc_msg.lParam);
    }

    // Return execute result
    return true;
}

/**
 * @brief Release a child process
 *
 * @param procIndex Child process index (Start with: 0)
 */
void ofw::IServiceDaemon::releaseChildProcess(uint procIndex)
{
    // Check if the child process list is empty
    if (!this->childList) return;

    // The child process has been released
    if (!this->childList[procIndex].procHandle)
    {
        ::memset(&this->childList[procIndex], 0, sizeof(TChildProcess));
    }
    // The child process was not started correctly
    else if (this->childList[procIndex].procHandle && !this->childList[procIndex].procMsgTid)
    {
        ::TerminateProcess(this->childList[procIndex].procHandle, EXIT_FAILURE);
    }
    // The child process was started successfully
    else if (this->childList[procIndex].procHandle)
    {
        // Define temporary variables
        DWORD exit_code; // Child process exit code

        // Send a control message to terminate the child process
        while (!::PostThreadMessageA(this->childList[procIndex].procMsgTid, WM_CTRL_CHILD_PROC_STOP, OFW_CUR_THREAD_ID, procIndex + 1))
        {
            if (::GetExitCodeProcess(this->childList[procIndex].procHandle, &exit_code) && exit_code == STILL_ACTIVE)
                ofw::sleep_milliseconds(50);
            else
                break;
        }

        // Wait for child process to terminate
        ::WaitForSingleObject(this->childList[procIndex].procHandle, INFINITE);
    }

    // Close child process handle
    if (this->childList[procIndex].procHandle) ::CloseHandle(this->childList[procIndex].procHandle);

    // Reset child process information
    ::memset(&this->childList[procIndex], 0, sizeof(TChildProcess));
}

/**
 * @brief Create and daemonize child processes
 *
 * @return Whether the execute is successful
 */
bool ofw::IServiceDaemon::daemonChildProcesses()
{
    // Define inside variable
    std::unique_ptr<char[]> svc_name = ofw::utf8_to_ansi(this->svcName); // The service name of the ANSI encoding

    // The current process is the main process
    if (!ofw::is_same_parent_process_app())
    {
        // Define temporary variables
        SERVICE_TABLE_ENTRY table_entry[] = {{svc_name.get(), (LPSERVICE_MAIN_FUNCTION)ServiceMain}, {nullptr, nullptr}}; // Service Start Table

        // Start service control dispatcher, and return exit code
        if (::StartServiceCtrlDispatcherA(table_entry) != TRUE)
        {
            this->writeSystemEventLog("Failed to start service control dispatcher.", EVENTLOG_ERROR_TYPE);
            return false;
        }
    }

    // Return execute result
    return true;
}

/**
 * @brief Construct function
 *
 * @param svcInstance IServiceBase instance
 * @param svcName     Service name
 * @param childTotal  The child processes total
 */
ofw::IServiceDaemon::IServiceDaemon(IServiceBase * svcInstance, const char * svcName, uint childTotal) : svcInstance(svcInstance), svcStopping(false),
                                                                                                         childTotal(childTotal), childList(nullptr),
                                                                                                         svcStatusHandle(0), svcCheckPoint(1)
{
    // Record self instance
    this->This = this;

    // Set the current service name
    this->svcName = new char[::strlen(svcName) + 1];
    ::memcpy(this->svcName, svcName, ::strlen(svcName) + 1);

    // Set the current application path
    this->svcAppPath = ofw::get_app_path();

    // Configure the default state of the service
    this->svcStatus.dwControlsAccepted        = SERVICE_CONTROLS_ACCEPTED;
    this->svcStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    this->svcStatus.dwCurrentState            = SERVICE_START_PENDING;
    this->svcStatus.dwWin32ExitCode           = NO_ERROR;
    this->svcStatus.dwServiceSpecificExitCode = 0;
    this->svcStatus.dwCheckPoint              = 0;
    this->svcStatus.dwWaitHint                = 0;
}

/**
 * @brief Destruct function
 */
ofw::IServiceDaemon::~IServiceDaemon()
{
    // Release the service name
    if (this->svcName) delete[] this->svcName;

    // Release the child processes pid list
    if (this->childList) delete[] this->childList;

    // Release the self
    this->This = nullptr;
}
#endif
#ifdef _LINUX
/**
 * @brief [STATIC] Signal handler
 *
 * @param sigNum     Trigger signal
 * @param sigInfo    Signal information
 * @param sigContext Signal context
 */
void ofw::IServiceDaemon::SignalHandler(int sigNum, siginfo_t * sigInfo, void * sigContext)
{
    // Main process
    if (!ofw::IServicePrivate::This)
    {
        switch (sigNum)
        {
            // Process termination signal
            case SIGTERM: 
            {
                // Change service status to stopping
                ofw::IServiceDaemon::This->svcStopping = true;
                break;
            }
            // Child process termination signal
            case SIGCHLD:
            {
                // If the current service is not stopping, trigger the child process termination handler function
                if (!ofw::IServiceDaemon::This->svcStopping) ofw::IServiceDaemon::This->onChildTerminate(sigInfo->si_pid);
                break;
            }
            // Default break
            default:
                break;
        }
    }
    // Child process
    else
    {
        switch (sigNum)
        {
            // Process termination signal
            case SIGTERM:
            // Request termination signal (Sent by the parent process)
            case SIGCHLD:
            {
                // Change child process status to stopping
                ofw::IServicePrivate::This->svcStopping = true;
                break;
            }
            // Default break
            default:
                break;
        }
    }
}

/**
 * @brief Create a PID file of the daemon service
 *
 * @return Whether the create was successful
 */
bool ofw::IServiceDaemon::createPidFile()
{
    // Define inside variable
    bool ret_status = false; // The status value used to return
    bool pid_locked = false; // The PID file locked
    int  pid_filedp = 0;     // The PID file descriptor

    // Create a PID file
    do
    {
        // Define temporary variables
        std::unique_ptr<char[]> file_path(new char[MAX_PATH + 1]);    // PID file path
        std::string             pid_str = std::to_string(::getpid()); // Process id string

        // Generate PID file path
        ::memset(file_path.get(), 0, (MAX_PATH + 1) * sizeof(char));
        if (::sprintf(file_path.get(), "/run/%s.pid", this->svcName) <= 0) return false;

        // Open pid file
        if ((pid_filedp = ::open(file_path.get(), O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)) == -1) break;

        // Lock pid file
        if (!(pid_locked = (::flock(pid_filedp, LOCK_EX) != -1))) break;

        // Write pid file
        ret_status = (::write(pid_filedp, pid_str.c_str(), pid_str.length()) > 0);
    } while (false);

    // Release file descriptor
    if (pid_locked) ::flock(pid_filedp, LOCK_UN);
    if (pid_filedp) ::close(pid_filedp);

    // Return execute result
    return ret_status;
}

/**
 * @brief Remove a PID file of the daemon service
 *
 * @return Whether the remove was successful
 */
bool ofw::IServiceDaemon::removePidFile()
{
    // Define inside variable
    bool ret_status = false; // The status value used to return

    // Remove a PID file
    {
        // Generate PID file path
        std::unique_ptr<char[]> file_path(new char[MAX_PATH + 1]);
        ::memset(file_path.get(), 0, (MAX_PATH + 1) * sizeof(char));
        if (::sprintf(file_path.get(), "/var/run/%s.pid", this->svcName) <= 0) return false;

        // Remove a PID file
        if (!ofw::remove_path(file_path.get())) return false;
    }

    // Return execute result
    return ret_status;
}

/**
 * @brief Handle child process termination event
 *
 * @param childPid PID of the child process
 */
void ofw::IServiceDaemon::onChildTerminate(pid_t childPid)
{
    // Define inside variable
    pid_t child_pid    = 0; // Child process pid
    int   child_status = 0; // Child process status

    // Wait child process terminate
    while (true)
    {
        // Wait child process terminate
        child_pid = ::waitpid(childPid, &child_status, WUNTRACED | WCONTINUED);
        if (child_pid == -1)
        {
            if (errno == EINTR) continue;
            OFW_PERROR(OFW_ERR_L_FATAL, "Fialed to wait child process terminate:");
            exit(EXIT_FAILURE);
        }

        // The process actively exits
        if (WIFEXITED(child_status))
        {
            if (WEXITSTATUS(child_status) != EXIT_SUCCESS) OFW_WARNING("Child process exited unexpectedly: %d", WEXITSTATUS(child_status));
        }
        // Process terminated passively
        else if (WIFSIGNALED(child_status))
        {
            if (WEXITSTATUS(child_status) != EXIT_SUCCESS) OFW_WARNING("Child process terminated passively: %s", ::strsignal(WTERMSIG(child_status)));
        }
        // Process paused
        else if (WIFSTOPPED(child_status))
        {
            OFW_INFORMATION("Child process paused: %s", ::strsignal(WSTOPSIG(child_status)));
        }
        // Process continued
        else if (WIFCONTINUED(child_status))
        {
            OFW_INFORMATION("Child process continued.");
        }

        // Check process terminate
        // Due to the use of do{}while(...){} mode, there is an unknown process exception problem, so this method is used
        if (!this->svcStopping || WIFEXITED(child_status) || WIFSIGNALED(child_status)) break;
    }

    // Set the paused child process to continue
    if (!this->svcStopping)
    {
        if (WIFCONTINUED(child_status)) return;
        if (WIFSTOPPED(child_status))
        {
            ::kill(childPid, SIGCONT);
            return;
        }
    }

    // Updates the current child process information in a subset of processes
    if (this->childList)
    {
        for (uint child_idx = 0; child_idx < this->childTotal; child_idx++)
        {
            if (this->childList[child_idx] == childPid) this->childList[child_idx] = 0;
        }
    }
}

/**
 * @brief Convert the current process to a daemon
 *
 * @param isChdir Whether to change the working directory (Change to "/")
 * @param noPrint Whether to disable print (Disable console output)
 * @return Whether the conversion was successful
 */
bool ofw::IServiceDaemon::initDaemonProcess(bool isChdir, bool noPrint)
{
    // Create child processe
    switch (::fork())
    {
        // Failure
        case -1: { OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: fork error."); return false; }
        // The child process continues execution
        case 0:  { break; }
        // Terminates the current process
        default: { ::_exit(EXIT_SUCCESS);                                                return true; }
    }

    // Creates a session and sets the process group ID (Break away controlling terminals, login sessions, and process groups)
    if (::setsid() == -1) return false;

    // Change the working directory (Change to "/")
    if (isChdir && ::chdir("/") != 0)
    {
        OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: chdir error.");
        return false;
    }

    // Disable standard input and output (Disable console I/O)
    if (noPrint)
    {
        // Define temporary variables
        int null_fd = ::open("/dev/null", O_RDWR, 0); // The file descriptor for an empty device

        // Disable application standard input and output
        if (null_fd == -1)                    { OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: open[\"/dev/null\"] error."); return false; }
        if (dup2(null_fd, STDIN_FILENO)  < 0) { OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: dup2[STDIN_FILENO] error.");  return false; }
        if (dup2(null_fd, STDOUT_FILENO) < 0) { OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: dup2[STDOUT_FILENO] error."); return false; }
        if (dup2(null_fd, STDERR_FILENO) < 0) { OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: dup2[STDERR_FILENO] error."); return false; }
        if (null_fd > STDERR_FILENO && ::close(null_fd) < 0)
        {
            OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init daemonize: close file descriptor error.");
            return false;
        }
    }

    // Generate a pid file for the service
    if (!This->createPidFile()) return false;

    // Return execute result
    return true;
}

/**
 * @brief Initialize the listening signal of the current process
 *
 * @return Whether the initialize is successful
 */
bool ofw::IServiceDaemon::initListenSignals()
{
    // Define inside variable
    struct sigaction    sig_action;                           // Structure that specifies how to handle a signal
    std::map<int, bool> all_signals = SERVICE_LISTEN_SIGNALS; // All signals to process

    // Set up signal processing functions, or ignore signal processing
    for (std::map<int, bool>::iterator it_signal = all_signals.begin(); it_signal != all_signals.end(); it_signal++)
    {
        // Reset structure datas
        ::memset(&sig_action, 0, sizeof(sig_action));

        // Specifies how signals are processed
        if (it_signal->second)
        {
            // Set signal handler function
            sig_action.sa_flags     = SA_SIGINFO;
            sig_action.sa_sigaction = ofw::IServiceDaemon::SignalHandler;
        }
        else
        {
            // Ignore the signal
            sig_action.sa_handler = SIG_IGN;
        }

        // Initialise and empty a signal set
        ::sigemptyset(&sig_action.sa_mask);

        // Examine and change a signal action
        if (::sigaction(it_signal->first, &sig_action, nullptr) == -1)
        {
            OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init signals: sigaction error.");
            return false;
        }
    }

    // Set the signals to block (Shield the target signals)
    {
        // Initialise and empty a signal set
        ::sigemptyset(&sig_action.sa_mask);

        // Add signals to ignore to signal set
        for (std::map<int, bool>::iterator it_signal = all_signals.begin(); it_signal != all_signals.end(); it_signal++)
        {
            if (!it_signal->second) ::sigaddset(&sig_action.sa_mask, it_signal->first);
        }

        // Set the signals to block
        if (::sigprocmask(SIG_BLOCK, &sig_action.sa_mask, NULL) == -1)
        {
            OFW_PERROR(OFW_ERR_L_FATAL, "Failed to init signals: sigprocmask error.");
            return false;
        }
    }

    // Return execute result
    return true;
}

/**
 * @brief Create and daemonize child processes
 *
 * @return Whether the execute is successful
 */
bool ofw::IServiceDaemon::daemonChildProcesses()
{
    // Define inside variable
    sigset_t sig_set; // Signal set

    // Check parameters for validity
    OFW_CHECK(this->childTotal > 0, EINVAL, return false);

    // Initialise and empty a signal set
    ::sigemptyset(&sig_set);

    // Initialize the pid list of the child processes
    if (this->childList != NULL) return false;
    this->childList = new pid_t[this->childTotal];
    ::memset(this->childList, 0, this->childTotal * sizeof(pid_t));

    // Create and daemonize child processes
    while (!this->svcStopping)
    {
        // Define temporary variables
        pid_t proc_pid = 0; // Process pid

        // Check the child processes status
        for (uint child_idx = 0; child_idx < this->childTotal; child_idx++)
        {
            // Check the child process status
            if (this->childList[child_idx] > 0) continue;

            // Resurrect child process
            switch (proc_pid = ::fork())
            {
                // Failure
                case -1:
                {
                    // Output error message
                    OFW_PERROR(OFW_ERR_L_FATAL, "Failed to initialize child process:");
                    break;
                }
                // Currently a child process
                case 0:
                {
                    // Initialize service private and returns directly
                    new IServicePrivate(this->svcInstance, child_idx + 1);
                    return true;
                }
                // The main process continues execution
                default:
                    break;
            }

            // Break out of loop if resurrect child process fails
            if (proc_pid == -1) break;

            // Record child process information
            this->childList[child_idx] = proc_pid;
        }

        // If resuming the child process fails, rest for 1 second and try again
        if (proc_pid == -1)
        {
            ofw::sleep_seconds(1);
            continue;
        }

        // Wait for the next signal (Blocks the current process until returning from any signal handler)
        ::sigsuspend(&sig_set);
    }

    // Terminate all child processes
    for (int proc_idx = this->childTotal - 1; proc_idx >= 0; proc_idx--)
    {
        // Invalid child processes are ignored
        if (this->childList[proc_idx] <= 0) continue;

        // Sends a termination signal to the child process
        ::kill(this->childList[proc_idx], SIGCHLD);

        // Trigger the child process termination handler function
        this->onChildTerminate(this->childList[proc_idx]);
    }
    
    // Return execute result
    return true;
}

/**
 * @brief Construct function
 *
 * @param svcInstance IService instance
 * @param svcName     Service name
 * @param childTotal  The child processes total
 */
ofw::IServiceDaemon::IServiceDaemon(IServiceBase * svcInstance, const char * svcName, uint childTotal) : svcInstance(svcInstance), svcStopping(false), childTotal(childTotal), childList(nullptr)
{
    // Set the self
    this->This = this;

    // Set the service name
    this->svcName = new char[::strlen(svcName) + 1];
    ::memcpy(this->svcName, svcName, ::strlen(svcName) + 1);
}

/**
 * @brief Destruct function
 */
ofw::IServiceDaemon::~IServiceDaemon()
{
    // Remove a PID file
    if (!ofw::IServicePrivate::This) this->removePidFile();

    // Release the service name
    if (this->svcName) delete[] this->svcName;

    // Release the child processes pid list
    if (this->childList) delete[] this->childList;

    // Release the self
    this->This = nullptr;
}
#endif

//################################################################################
// Initialize inside variable
//################################################################################
/**
 * @brief A static instance of IServiceDaemon
 */
ofw::IServiceDaemon * ofw::IServiceDaemon::This = nullptr;

/**
 * @brief A static instance of IServicePrivate
 */
ofw::IServicePrivate * ofw::IServicePrivate::This = nullptr;

//################################################################################
// Implementation export method
//################################################################################
/**
 * @brief Construct function
 *
 * @param svcName  Service name
 * @param subTotal Number of child processes
 */
ofw::IServiceBase::IServiceBase(const char * svcName, uint subTotal)
{
#ifdef _WINDOWS
    // The current process is the main process
    if (!ofw::is_same_parent_process_app())
    {
        // Initialize service daemon
        new ofw::IServiceDaemon(this, svcName, subTotal);
    }
    // The current process is the child process
    else
    {
        // Initialize service private
        new ofw::IServicePrivate(this, 0);

        // Wait for the current process to synchronize with the daemon data
        {
            // Define temporary variables
            MSG recv_msg = {0}; // Current received message

            // Waiting to get process index from daemon process
            while (true)
            {
                // Wait for the parent process to send a message to the current child process
                if (!::GetMessageA(&recv_msg, nullptr, 0, 0)) continue;

                // The parent process terminates the child process
                if (recv_msg.message == WM_CTRL_CHILD_PROC_STOP) ::ExitProcess(0);

                // The message that the parent process sets the index of the child process
                if (recv_msg.message == WM_CHILD_PROC_CUR_IDX)
                {
                    ofw::IServicePrivate::This->procIndex = static_cast<uint>(recv_msg.lParam);
                    break;
                }
            }

            // Create message receiving thread
            ofw::IServicePrivate::This->msgThread = ::CreateThread(NULL, NULL, ofw::IServicePrivate::MessageThread, reinterpret_cast<LPVOID>(recv_msg.wParam), NULL, NULL);
            if (!ofw::IServicePrivate::This->msgThread) ::ExitProcess(ofw::IServicePrivate::This->procIndex);

            // Send a message thread id of the child process
            {
                // Define temporary variables
                HANDLE parent_handle = ::OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, ofw::get_parent_process_id()); // Parent process handle
                DWORD  exit_code     = 0;                                                                             // Parent process exit code

                // Send message thread id to daemon process
                while (!::PostThreadMessageA(static_cast<DWORD>(recv_msg.wParam), WM_CHILD_PROC_MSG_TID, OFW_CUR_THREAD_ID, ::GetThreadId(ofw::IServicePrivate::This->msgThread)))
                {
                    // The daemon process is not terminated
                    if (::GetExitCodeProcess(parent_handle, &exit_code) && exit_code == STILL_ACTIVE)
                    {
                        ofw::sleep_milliseconds(50);
                    }
                    // The daemon process was terminated
                    else
                    {
                        ::CloseHandle(parent_handle);
                        ::TerminateThread(ofw::IServicePrivate::This->msgThread, EXIT_FAILURE);
                        ::ExitProcess(ofw::IServicePrivate::This->procIndex);
                        break;
                    }
                }

                // Close parent process handle
                ::CloseHandle(parent_handle);
            }
        }
    }
#endif
#ifdef _LINUX
    // Initialize service daemon
    new ofw::IServiceDaemon(this, svcName, subTotal);
#endif
}

/**
 * @brief Destruct function
 */
ofw::IServiceBase::~IServiceBase()
{
    // Release service daemon
    if (ofw::IServiceDaemon::This) delete ofw::IServiceDaemon::This;

    // Release service private
    if (ofw::IServicePrivate::This) delete ofw::IServicePrivate::This;
}

/**
 * @brief Get the current process index
 *
 * @return The current process index (Main process: 0; Child process start with: 1)
 */
bool ofw::IServiceBase::processIndex()
{
    // The child process return service private information
    if (ofw::IServicePrivate::This) return ofw::IServicePrivate::This->procIndex;

    // The main process return 0
    return 0;
}

/**
 * @brief Check whether the service is terminated
 *
 * @return Whether the service is terminated
 */
bool ofw::IServiceBase::isTerminated()
{
    // The child process return service private information, The main process return service daemon information
    return (ofw::IServicePrivate::This ? ofw::IServicePrivate::This->svcStopping : ofw::IServiceDaemon::This->svcStopping);
}

/**
 * @brief Service on start event (Used only for the main process)
 *
 * @return Whether the start was successful
 */
bool ofw::IServiceBase::onStart()
{
    // Return execute result
    return true;
}

/**
 * @brief The principal execution portion of the service (Used only for child processes)
 * @details The service will automatically stop when this process is complete
 *
 * @param procIndex Child process index (Start with: 1)
 * @return Whether the execute was successful
 */
bool ofw::IServiceBase::onExecute(int procIndex)
{
    // Waiting to get process index
    while (!this->isTerminated()) ofw::sleep_milliseconds(100);

    // Return execute result
    return true;
}

/**
 * @brief Service on stop event (Used only for the main process)
 *
 * @return Whether the stop was successful
 */
bool ofw::IServiceBase::onStop()
{
    // Return execute result
    return true;
}

/**
 * @brief Start the service execution
 *
 * @return Exit code (EXIT_SUCCESS: successed; Other: failed)
 */
int ofw::IServiceBase::exec()
{
#ifdef _WINDOWS
    // The current process is the main process
    if (ofw::IServiceDaemon::This)
    {
        // Start daemon service
        if (!ofw::IServiceDaemon::This->svcInstance->onStart()) return EXIT_FAILURE;
        if (!ofw::IServiceDaemon::This->daemonChildProcesses()) return EXIT_FAILURE;
        if (!ofw::IServiceDaemon::This->svcInstance->onStop())  return EXIT_FAILURE;
    }
    // The current process is the child process
    else
    {
        // The principal execution part of the child process service that runs
        if (!ofw::IServicePrivate::This->svcInstance->onExecute(ofw::IServicePrivate::This->procIndex)) return EXIT_FAILURE;
    }
#endif
#ifdef _LINUX
    // Start daemon service
    if (!ofw::IServiceDaemon::This->svcInstance->onStart())                               return EXIT_FAILURE;
    if (!ofw::IServiceDaemon::This->initDaemonProcess(false, true))                       return EXIT_FAILURE;
    if (!ofw::IServiceDaemon::This->initListenSignals())                                  return EXIT_FAILURE;
    if (!ofw::IServiceDaemon::This->daemonChildProcesses())                               return EXIT_FAILURE;
    if (!ofw::IServicePrivate::This && !ofw::IServiceDaemon::This->svcInstance->onStop()) return EXIT_FAILURE;

    // Currently a child process
    if (ofw::IServicePrivate::This)
    {
        // Relase service daemon
        delete ofw::IServiceDaemon::This;

        // Run child process
        if (!ofw::IServicePrivate::This->svcInstance->onExecute(ofw::IServicePrivate::This->procIndex)) return EXIT_FAILURE;
    }
#endif

    // Return execute result
    return EXIT_SUCCESS;
}
